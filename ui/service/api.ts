/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Model Editor API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:8081/meditor/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    createdOn: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    createdBy: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    text: string;
    /**
     * 
     * @type {boolean}
     * @memberof Comment
     */
    resolved: boolean;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    resolvedBy: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    parentId: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    documentId: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    lastEdited?: string;
}

/**
 * 
 * @export
 * @interface Csrf
 */
export interface Csrf {
    /**
     * CSRF token
     * @type {string}
     * @memberof Csrf
     */
    csrfToken?: string;
}

/**
 * 
 * @export
 * @interface DocCatalogEntry
 */
export interface DocCatalogEntry {
    /**
     * Title for the document
     * @type {string}
     * @memberof DocCatalogEntry
     */
    title?: string;
    /**
     * 
     * @type {DocCatalogEntryXmeditor}
     * @memberof DocCatalogEntry
     */
    xMeditor?: DocCatalogEntryXmeditor;
}

/**
 * 
 * @export
 * @interface DocCatalogEntryXmeditor
 */
export interface DocCatalogEntryXmeditor {
    /**
     * Date-time of modification
     * @type {string}
     * @memberof DocCatalogEntryXmeditor
     */
    modifiedOn?: string;
    /**
     * Modifier's user name
     * @type {string}
     * @memberof DocCatalogEntryXmeditor
     */
    modifiedBy?: string;
    /**
     * State of the document wrt document workflow
     * @type {string}
     * @memberof DocCatalogEntryXmeditor
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface DocHistory
 */
export interface DocHistory {
    /**
     * 
     * @type {string}
     * @memberof DocHistory
     */
    modifiedBy: string;
    /**
     * 
     * @type {Date}
     * @memberof DocHistory
     */
    modifiedOn: Date;
}

/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * 
     * @type {DocCatalogEntryXmeditor}
     * @memberof Document
     */
    xMeditor?: DocCatalogEntryXmeditor;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    layout?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    doc?: string;
}

/**
 * 
 * @export
 * @interface Error
 */
export interface Error {
    /**
     * 
     * @type {number}
     * @memberof Error
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * 
     * @type {ModelXmeditor}
     * @memberof Model
     */
    xMeditor?: ModelXmeditor;
    /**
     * Name of the model
     * @type {string}
     * @memberof Model
     */
    name: string;
    /**
     * Model's description
     * @type {string}
     * @memberof Model
     */
    description: string;
    /**
     * Display category
     * @type {string}
     * @memberof Model
     */
    category?: string;
    /**
     * Name of the workflow to use with the model's documents
     * @type {string}
     * @memberof Model
     */
    workflow?: string;
    /**
     * 
     * @type {ModelIcon}
     * @memberof Model
     */
    icon: ModelIcon;
    /**
     * Model's schema
     * @type {string}
     * @memberof Model
     */
    schema: string;
    /**
     * Model layout based on Angular JSON Schema form
     * @type {string}
     * @memberof Model
     */
    layout: string;
    /**
     * Property name in the Model's schema for using as title of the document instance of the model
     * @type {string}
     * @memberof Model
     */
    titleProperty?: string;
    /**
     * Any documentation (text) for the Model
     * @type {string}
     * @memberof Model
     */
    documentation?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Model
     */
    tag?: Array<string>;
}

/**
 * 
 * @export
 * @interface ModelCatalogEntry
 */
export interface ModelCatalogEntry {
    /**
     * 
     * @type {ModelCatalogEntryXmeditor}
     * @memberof ModelCatalogEntry
     */
    xMeditor?: ModelCatalogEntryXmeditor;
    /**
     * Name of the model (ex: FAQ, Alert, Collection etc.,): displayed to the user in UI
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    name: string;
    /**
     * Description of the model (ex: FAQ, Alert, Collection etc.,): description of the model; might be shown to user as a tooltip
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    description: string;
    /**
     * Category/group to which the model belongs; to be used for display purposes only
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    category?: string;
    /**
     * Workflow to be used in processing documents belonging to the model
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    workflow?: string;
    /**
     * 
     * @type {ModelIcon}
     * @memberof ModelCatalogEntry
     */
    icon?: ModelIcon;
    /**
     * JSON Schema of the model itself
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    schema?: string;
    /**
     * Link to model's documentation
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    documentation?: string;
    /**
     * An array of tags associated with the model: can be used for searching models
     * @type {Array<string>}
     * @memberof ModelCatalogEntry
     */
    tag?: Array<string>;
}

/**
 * 
 * @export
 * @interface ModelCatalogEntryXmeditor
 */
export interface ModelCatalogEntryXmeditor {
    /**
     * JSON path to the field in the Model to be used as title in displays
     * @type {string}
     * @memberof ModelCatalogEntryXmeditor
     */
    title?: string;
    /**
     * Date-time of modification
     * @type {string}
     * @memberof ModelCatalogEntryXmeditor
     */
    modifiedOn?: string;
    /**
     * Modifier's user name
     * @type {string}
     * @memberof ModelCatalogEntryXmeditor
     */
    modifiedBy?: string;
    /**
     * Version of the model represented by date-time of modification
     * @type {string}
     * @memberof ModelCatalogEntryXmeditor
     */
    version?: string;
    /**
     * Number of instances of the model
     * @type {number}
     * @memberof ModelCatalogEntryXmeditor
     */
    count?: number;
}

/**
 * Icon for the model: currently limited to Font Awesome
 * @export
 * @interface ModelIcon
 */
export interface ModelIcon {
    /**
     * Name of the Font Awesome icon (ex: )
     * @type {string}
     * @memberof ModelIcon
     */
    name?: string;
    /**
     * Background color to be used for the Font Awesome icon (ex: )
     * @type {string}
     * @memberof ModelIcon
     */
    color?: string;
}

/**
 * 
 * @export
 * @interface ModelXmeditor
 */
export interface ModelXmeditor {
    /**
     * Name of the field in the model to be used as a title
     * @type {string}
     * @memberof ModelXmeditor
     */
    title?: string;
    /**
     * Date when a last document edit was made
     * @type {string}
     * @memberof ModelXmeditor
     */
    modifiedOn?: string;
    /**
     * Author who last modified a document belonging to the model
     * @type {string}
     * @memberof ModelXmeditor
     */
    modifiedBy?: string;
    /**
     * Number of documents belonging to the model
     * @type {string}
     * @memberof ModelXmeditor
     */
    count?: string;
}

/**
 * 
 * @export
 * @interface Success
 */
export interface Success {
    /**
     * 
     * @type {number}
     * @memberof Success
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof Success
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Name of the user
     * @type {string}
     * @memberof User
     */
    name?: string;
}


/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change the state of a document; modifies the state of a document by a privileged user
         * @summary Change the state of a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document
         * @param {string} state Target state of the document
         * @param {string} [version] Version of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDocumentState(model: string, title: string, state: string, version?: string, options: any = {}): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling changeDocumentState.');
            }
            // verify required parameter 'title' is not null or undefined
            if (title === null || title === undefined) {
                throw new RequiredError('title','Required parameter title was null or undefined when calling changeDocumentState.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError('state','Required parameter state was null or undefined when calling changeDocumentState.');
            }
            const localVarPath = `/changeDocumentState`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit comment
         * @summary Edit comment
         * @param {string} id Comment id
         * @param {string} text New text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editComment(id: string, text: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editComment.');
            }
            // verify required parameter 'text' is not null or undefined
            if (text === null || text === undefined) {
                throw new RequiredError('text','Required parameter text was null or undefined when calling editComment.');
            }
            const localVarPath = `/editComment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets comments for document
         * @summary Gets comments for document
         * @param {string} title Title of the document
         * @param {string} model Model of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(title: string, model: string, options: any = {}): FetchArgs {
            // verify required parameter 'title' is not null or undefined
            if (title === null || title === undefined) {
                throw new RequiredError('title','Required parameter title was null or undefined when calling getComments.');
            }
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling getComments.');
            }
            const localVarPath = `/getComments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a new csrf token
         * @summary Gets a new csrf token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsrfToken(options: any = {}): FetchArgs {
            const localVarPath = `/getCsrfToken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication URS4 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("URS4", ["read", "write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a document
         * @summary Gets a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document
         * @param {string} [version] Version of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument(model: string, title: string, version?: string, options: any = {}): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling getDocument.');
            }
            // verify required parameter 'title' is not null or undefined
            if (title === null || title === undefined) {
                throw new RequiredError('title','Required parameter title was null or undefined when calling getDocument.');
            }
            const localVarPath = `/getDocument`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a document's history
         * @summary Gets a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentHistory(model: string, title: string, options: any = {}): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling getDocumentHistory.');
            }
            // verify required parameter 'title' is not null or undefined
            if (title === null || title === undefined) {
                throw new RequiredError('title','Required parameter title was null or undefined when calling getDocumentHistory.');
            }
            const localVarPath = `/getDocumentHistory`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets user info
         * @summary Gets user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options: any = {}): FetchArgs {
            const localVarPath = `/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication URS4 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("URS4", ["read", "write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            localVarRequestOptions.credentials = 'include'

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a Model object
         * @summary Gets a Model
         * @param {string} name Name of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getModel.');
            }
            const localVarPath = `/getModel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication URS4 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("URS4", ["read", "write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists documents of a given Model
         * @summary Lists documents of a given Model
         * @param {string} model Name of the Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(model: string, options: any = {}): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling listDocuments.');
            }
            const localVarPath = `/listDocuments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists 'Model' objects each with an icon, description and count of number of instances of an object.
         * @summary Lists Models
         * @param {Array<string>} [properties] Comma-separated list of fields to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(properties?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/listModels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication URS4 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("URS4", ["read", "write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (properties) {
                localVarQueryParameter['properties'] = properties.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs in a user  
         * @summary Login
         * @param {string} [code] URS authentication code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(code?: string, options: any = {}): FetchArgs {
            const localVarPath = `/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs out the user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options: any = {}): FetchArgs {
            const localVarPath = `/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Puts comment for document
         * @summary Puts comment for document
         * @param {any} file Uploaded comment (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment(file: any, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling postComment.');
            }
            const localVarPath = `/postComment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Puts a document
         * @summary Puts a document
         * @param {any} file Uploaded document file (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDocument(file: any, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling putDocument.');
            }
            const localVarPath = `/putDocument`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData()

            // authentication URS4 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("URS4", ["read", "write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }

            //localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, options.headers);
            localVarRequestOptions.body = localVarFormParams//.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Model object
         * @summary Adds a Model
         * @param {any} file Uploaded model file (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putModel(file: any, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling putModel.');
            }
            const localVarPath = `/putModel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication URS4 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("URS4", ["read", "write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves comment
         * @summary Resolves comment
         * @param {string} id Comment id
         * @param {string} resolvedBy Resolved by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveComment(id: string, resolvedBy: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resolveComment.');
            }
            // verify required parameter 'resolvedBy' is not null or undefined
            if (resolvedBy === null || resolvedBy === undefined) {
                throw new RequiredError('resolvedBy','Required parameter resolvedBy was null or undefined when calling resolveComment.');
            }
            const localVarPath = `/resolveComment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (resolvedBy !== undefined) {
                localVarQueryParameter['resolvedBy'] = resolvedBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Change the state of a document; modifies the state of a document by a privileged user
         * @summary Change the state of a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document
         * @param {string} state Target state of the document
         * @param {string} [version] Version of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDocumentState(model: string, title: string, state: string, version?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).changeDocumentState(model, title, state, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Edit comment
         * @summary Edit comment
         * @param {string} id Comment id
         * @param {string} text New text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editComment(id: string, text: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).editComment(id, text, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets comments for document
         * @summary Gets comments for document
         * @param {string} title Title of the document
         * @param {string} model Model of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(title: string, model: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getComments(title, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a new csrf token
         * @summary Gets a new csrf token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsrfToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Csrf> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getCsrfToken(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a document
         * @summary Gets a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document
         * @param {string} [version] Version of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument(model: string, title: string, version?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getDocument(model, title, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a document's history
         * @summary Gets a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentHistory(model: string, title: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getDocumentHistory(model, title, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets user info
         * @summary Gets user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getMe(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets a Model object
         * @summary Gets a Model
         * @param {string} name Name of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Model> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getModel(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists documents of a given Model
         * @summary Lists documents of a given Model
         * @param {string} model Name of the Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(model: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DocCatalogEntry>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).listDocuments(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists 'Model' objects each with an icon, description and count of number of instances of an object.
         * @summary Lists Models
         * @param {Array<string>} [properties] Comma-separated list of fields to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(properties?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelCatalogEntry>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).listModels(properties, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Logs in a user  
         * @summary Login
         * @param {string} [code] URS authentication code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(code?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).login(code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Logs out the user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).logout(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Puts comment for document
         * @summary Puts comment for document
         * @param {any} file Uploaded comment (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment(file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).postComment(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Puts a document
         * @summary Puts a document
         * @param {any} file Uploaded document file (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDocument(file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).putDocument(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a Model object
         * @summary Adds a Model
         * @param {any} file Uploaded model file (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putModel(file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).putModel(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resolves comment
         * @summary Resolves comment
         * @param {string} id Comment id
         * @param {string} resolvedBy Resolved by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveComment(id: string, resolvedBy: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).resolveComment(id, resolvedBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Change the state of a document; modifies the state of a document by a privileged user
         * @summary Change the state of a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document
         * @param {string} state Target state of the document
         * @param {string} [version] Version of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeDocumentState(model: string, title: string, state: string, version?: string, options?: any) {
            return DefaultApiFp(configuration).changeDocumentState(model, title, state, version, options)(fetch, basePath);
        },
        /**
         * Edit comment
         * @summary Edit comment
         * @param {string} id Comment id
         * @param {string} text New text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editComment(id: string, text: string, options?: any) {
            return DefaultApiFp(configuration).editComment(id, text, options)(fetch, basePath);
        },
        /**
         * Gets comments for document
         * @summary Gets comments for document
         * @param {string} title Title of the document
         * @param {string} model Model of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(title: string, model: string, options?: any) {
            return DefaultApiFp(configuration).getComments(title, model, options)(fetch, basePath);
        },
        /**
         * Gets a new csrf token
         * @summary Gets a new csrf token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsrfToken(options?: any) {
            return DefaultApiFp(configuration).getCsrfToken(options)(fetch, basePath);
        },
        /**
         * Gets a document
         * @summary Gets a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document
         * @param {string} [version] Version of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument(model: string, title: string, version?: string, options?: any) {
            return DefaultApiFp(configuration).getDocument(model, title, version, options)(fetch, basePath);
        },
        /**
         * Gets a document's history
         * @summary Gets a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentHistory(model: string, title: string, options?: any) {
            return DefaultApiFp(configuration).getDocumentHistory(model, title, options)(fetch, basePath);
        },
        /**
         * Gets user info
         * @summary Gets user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any) {
            return DefaultApiFp(configuration).getMe(options)(fetch, basePath);
        },
        /**
         * Gets a Model object
         * @summary Gets a Model
         * @param {string} name Name of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(name: string, options?: any) {
            return DefaultApiFp(configuration).getModel(name, options)(fetch, basePath);
        },
        /**
         * Lists documents of a given Model
         * @summary Lists documents of a given Model
         * @param {string} model Name of the Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(model: string, options?: any) {
            return DefaultApiFp(configuration).listDocuments(model, options)(fetch, basePath);
        },
        /**
         * Lists 'Model' objects each with an icon, description and count of number of instances of an object.
         * @summary Lists Models
         * @param {Array<string>} [properties] Comma-separated list of fields to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(properties?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).listModels(properties, options)(fetch, basePath);
        },
        /**
         * Logs in a user  
         * @summary Login
         * @param {string} [code] URS authentication code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(code?: string, options?: any) {
            return DefaultApiFp(configuration).login(code, options)(fetch, basePath);
        },
        /**
         * Logs out the user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any) {
            return DefaultApiFp(configuration).logout(options)(fetch, basePath);
        },
        /**
         * Puts comment for document
         * @summary Puts comment for document
         * @param {any} file Uploaded comment (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment(file: any, options?: any) {
            return DefaultApiFp(configuration).postComment(file, options)(fetch, basePath);
        },
        /**
         * Puts a document
         * @summary Puts a document
         * @param {any} file Uploaded document file (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDocument(file: any, options?: any) {
            return DefaultApiFp(configuration).putDocument(file, options)(fetch, basePath);
        },
        /**
         * Adds a Model object
         * @summary Adds a Model
         * @param {any} file Uploaded model file (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putModel(file: any, options?: any) {
            return DefaultApiFp(configuration).putModel(file, options)(fetch, basePath);
        },
        /**
         * Resolves comment
         * @summary Resolves comment
         * @param {string} id Comment id
         * @param {string} resolvedBy Resolved by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveComment(id: string, resolvedBy: string, options?: any) {
            return DefaultApiFp(configuration).resolveComment(id, resolvedBy, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Change the state of a document; modifies the state of a document by a privileged user
     * @summary Change the state of a document
     * @param {string} model Name of the Model
     * @param {string} title Title of the document
     * @param {string} state Target state of the document
     * @param {string} [version] Version of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public changeDocumentState(model: string, title: string, state: string, version?: string, options?: any) {
        return DefaultApiFp(this.configuration).changeDocumentState(model, title, state, version, options)(this.fetch, this.basePath);
    }

    /**
     * Edit comment
     * @summary Edit comment
     * @param {string} id Comment id
     * @param {string} text New text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editComment(id: string, text: string, options?: any) {
        return DefaultApiFp(this.configuration).editComment(id, text, options)(this.fetch, this.basePath);
    }

    /**
     * Gets comments for document
     * @summary Gets comments for document
     * @param {string} title Title of the document
     * @param {string} model Model of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getComments(title: string, model: string, options?: any) {
        return DefaultApiFp(this.configuration).getComments(title, model, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a new csrf token
     * @summary Gets a new csrf token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCsrfToken(options?: any) {
        return DefaultApiFp(this.configuration).getCsrfToken(options)(this.fetch, this.basePath);
    }

    /**
     * Gets a document
     * @summary Gets a document
     * @param {string} model Name of the Model
     * @param {string} title Title of the document
     * @param {string} [version] Version of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocument(model: string, title: string, version?: string, options?: any) {
        return DefaultApiFp(this.configuration).getDocument(model, title, version, options)(this.fetch, this.basePath);
    }

    /**
     * Gets a document's history
     * @summary Gets a document
     * @param {string} model Name of the Model
     * @param {string} title Title of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocumentHistory(model: string, title: string, options?: any) {
        return DefaultApiFp(this.configuration).getDocumentHistory(model, title, options)(this.fetch, this.basePath);
    }

    /**
     * Gets user info
     * @summary Gets user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMe(options?: any) {
        return DefaultApiFp(this.configuration).getMe(options)(this.fetch, this.basePath);
    }

    /**
     * Gets a Model object
     * @summary Gets a Model
     * @param {string} name Name of the model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getModel(name: string, options?: any) {
        return DefaultApiFp(this.configuration).getModel(name, options)(this.fetch, this.basePath);
    }

    /**
     * Lists documents of a given Model
     * @summary Lists documents of a given Model
     * @param {string} model Name of the Model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listDocuments(model: string, options?: any) {
        return DefaultApiFp(this.configuration).listDocuments(model, options)(this.fetch, this.basePath);
    }

    /**
     * Lists 'Model' objects each with an icon, description and count of number of instances of an object.
     * @summary Lists Models
     * @param {Array<string>} [properties] Comma-separated list of fields to be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listModels(properties?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listModels(properties, options)(this.fetch, this.basePath);
    }

    /**
     * Logs in a user  
     * @summary Login
     * @param {string} [code] URS authentication code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(code?: string, options?: any) {
        return DefaultApiFp(this.configuration).login(code, options)(this.fetch, this.basePath);
    }

    /**
     * Logs out the user
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logout(options?: any) {
        return DefaultApiFp(this.configuration).logout(options)(this.fetch, this.basePath);
    }

    /**
     * Puts comment for document
     * @summary Puts comment for document
     * @param {any} file Uploaded comment (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postComment(file: any, options?: any) {
        return DefaultApiFp(this.configuration).postComment(file, options)(this.fetch, this.basePath);
    }

    /**
     * Puts a document
     * @summary Puts a document
     * @param {any} file Uploaded document file (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putDocument(file: any, options?: any) {
        return DefaultApiFp(this.configuration).putDocument(file, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a Model object
     * @summary Adds a Model
     * @param {any} file Uploaded model file (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putModel(file: any, options?: any) {
        return DefaultApiFp(this.configuration).putModel(file, options)(this.fetch, this.basePath);
    }

    /**
     * Resolves comment
     * @summary Resolves comment
     * @param {string} id Comment id
     * @param {string} resolvedBy Resolved by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resolveComment(id: string, resolvedBy: string, options?: any) {
        return DefaultApiFp(this.configuration).resolveComment(id, resolvedBy, options)(this.fetch, this.basePath);
    }

}

