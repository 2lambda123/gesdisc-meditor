/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Model Editor API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as portableFetch from 'portable-fetch'
import * as url from 'url'
import type { Configuration } from './configuration'

const BASE_PATH = ''

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string
    options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration

    constructor(
        configuration?: Configuration,
        protected basePath: string = BASE_PATH,
        protected fetch: FetchAPI = portableFetch
    ) {
        if (configuration) {
            this.configuration = configuration
            this.basePath = configuration.basePath || this.basePath
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: 'RequiredError'
    constructor(public field: string, msg?: string) {
        super(msg)
    }
}

/**
 *
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    id: string
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    createdOn: string
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    createdBy: string
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    text: string
    /**
     *
     * @type {boolean}
     * @memberof Comment
     */
    resolved: boolean
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    resolvedBy: string
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    parentId: string
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    documentId: string
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    model: string
    /**
     *
     * @type {string}
     * @memberof Comment
     */
    lastEdited?: string
}

/**
 *
 * @export
 * @interface Csrf
 */
export interface Csrf {
    /**
     * CSRF token
     * @type {string}
     * @memberof Csrf
     */
    csrfToken?: string
}

/**
 *
 * @export
 * @interface DocCatalogEntry
 */
export interface DocCatalogEntry {
    /**
     * Title for the document
     * @type {string}
     * @memberof DocCatalogEntry
     */
    title?: string
    /**
     *
     * @type {DocCatalogEntryXmeditor}
     * @memberof DocCatalogEntry
     */
    xMeditor?: DocCatalogEntryXmeditor
}

/**
 *
 * @export
 * @interface DocCatalogEntryXmeditor
 */
export interface DocCatalogEntryXmeditor {
    /**
     * Date-time of modification
     * @type {string}
     * @memberof DocCatalogEntryXmeditor
     */
    modifiedOn?: string
    /**
     * Modifier's user name
     * @type {string}
     * @memberof DocCatalogEntryXmeditor
     */
    modifiedBy?: string
    /**
     * State of the document wrt document workflow
     * @type {string}
     * @memberof DocCatalogEntryXmeditor
     */
    state?: string
}

/**
 *
 * @export
 * @interface DocHistory
 */
export interface DocHistory {
    /**
     *
     * @type {string}
     * @memberof DocHistory
     */
    modifiedBy: string
    /**
     *
     * @type {Date}
     * @memberof DocHistory
     */
    modifiedOn: Date
}

/**
 *
 * @export
 * @interface Document
 */
export interface Document {
    /**
     *
     * @type {DocCatalogEntryXmeditor}
     * @memberof Document
     */
    xMeditor?: DocCatalogEntryXmeditor
    /**
     *
     * @type {string}
     * @memberof Document
     */
    schema?: string
    /**
     *
     * @type {string}
     * @memberof Document
     */
    layout?: string
    /**
     *
     * @type {string}
     * @memberof Document
     */
    doc?: string
}

/**
 *
 * @export
 * @interface Error
 */
export interface Error {
    /**
     *
     * @type {number}
     * @memberof Error
     */
    code?: number
    /**
     *
     * @type {string}
     * @memberof Error
     */
    description?: string
}

/**
 *
 * @export
 * @interface Model
 */
export interface Model {
    /**
     *
     * @type {ModelXmeditor}
     * @memberof Model
     */
    xMeditor?: ModelXmeditor
    /**
     * Name of the model
     * @type {string}
     * @memberof Model
     */
    name: string
    /**
     * Model's description
     * @type {string}
     * @memberof Model
     */
    description: string
    /**
     * Display category
     * @type {string}
     * @memberof Model
     */
    category?: string
    /**
     * Name of the workflow to use with the model's documents
     * @type {string}
     * @memberof Model
     */
    workflow?: string
    /**
     *
     * @type {ModelIcon}
     * @memberof Model
     */
    icon: ModelIcon
    /**
     * Model's schema
     * @type {string}
     * @memberof Model
     */
    schema: string
    /**
     * Model layout based on Angular JSON Schema form
     * @type {string}
     * @memberof Model
     */
    layout: string
    /**
     * Property name in the Model's schema for using as title of the document instance of the model
     * @type {string}
     * @memberof Model
     */
    titleProperty?: string
    /**
     * Any documentation (text) for the Model
     * @type {string}
     * @memberof Model
     */
    documentation?: string
    /**
     *
     * @type {Array<string>}
     * @memberof Model
     */
    tag?: Array<string>
}

/**
 *
 * @export
 * @interface ModelCatalogEntry
 */
export interface ModelCatalogEntry {
    /**
     *
     * @type {ModelCatalogEntryXmeditor}
     * @memberof ModelCatalogEntry
     */
    xMeditor?: ModelCatalogEntryXmeditor
    /**
     * Name of the model (ex: FAQ, Alert, Collection etc.,): displayed to the user in UI
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    name: string
    /**
     * Description of the model (ex: FAQ, Alert, Collection etc.,): description of the model; might be shown to user as a tooltip
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    description: string
    /**
     * Category/group to which the model belongs; to be used for display purposes only
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    category?: string
    /**
     * Workflow to be used in processing documents belonging to the model
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    workflow?: string
    /**
     *
     * @type {ModelIcon}
     * @memberof ModelCatalogEntry
     */
    icon?: ModelIcon
    /**
     * JSON Schema of the model itself
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    schema?: string
    /**
     * Link to model's documentation
     * @type {string}
     * @memberof ModelCatalogEntry
     */
    documentation?: string
    /**
     * An array of tags associated with the model: can be used for searching models
     * @type {Array<string>}
     * @memberof ModelCatalogEntry
     */
    tag?: Array<string>
}

/**
 *
 * @export
 * @interface ModelCatalogEntryXmeditor
 */
export interface ModelCatalogEntryXmeditor {
    /**
     * JSON path to the field in the Model to be used as title in displays
     * @type {string}
     * @memberof ModelCatalogEntryXmeditor
     */
    title?: string
    /**
     * Date-time of modification
     * @type {string}
     * @memberof ModelCatalogEntryXmeditor
     */
    modifiedOn?: string
    /**
     * Modifier's user name
     * @type {string}
     * @memberof ModelCatalogEntryXmeditor
     */
    modifiedBy?: string
    /**
     * Version of the model represented by date-time of modification
     * @type {string}
     * @memberof ModelCatalogEntryXmeditor
     */
    version?: string
    /**
     * Number of instances of the model
     * @type {number}
     * @memberof ModelCatalogEntryXmeditor
     */
    count?: number
}

/**
 * Icon for the model: currently limited to Font Awesome
 * @export
 * @interface ModelIcon
 */
export interface ModelIcon {
    /**
     * Name of the Font Awesome icon (ex: )
     * @type {string}
     * @memberof ModelIcon
     */
    name?: string
    /**
     * Background color to be used for the Font Awesome icon (ex: )
     * @type {string}
     * @memberof ModelIcon
     */
    color?: string
}

/**
 *
 * @export
 * @interface ModelXmeditor
 */
export interface ModelXmeditor {
    /**
     * Name of the field in the model to be used as a title
     * @type {string}
     * @memberof ModelXmeditor
     */
    title?: string
    /**
     * Date when a last document edit was made
     * @type {string}
     * @memberof ModelXmeditor
     */
    modifiedOn?: string
    /**
     * Author who last modified a document belonging to the model
     * @type {string}
     * @memberof ModelXmeditor
     */
    modifiedBy?: string
    /**
     * Number of documents belonging to the model
     * @type {string}
     * @memberof ModelXmeditor
     */
    count?: string
}

/**
 *
 * @export
 * @interface Success
 */
export interface Success {
    /**
     *
     * @type {number}
     * @memberof Success
     */
    code?: number
    /**
     *
     * @type {string}
     * @memberof Success
     */
    description?: string
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     * Name of the user
     * @type {string}
     * @memberof User
     */
    name?: string
}

/**
 *
 * @export
 * @interface Users
 */
export interface Users {
    /**
     *
     * @type {string}
     * @memberof Users
     */
    name: string
    /**
     *
     * @type {string}
     * @memberof Users
     */
    uid: string
}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clones a document
         * @summary Clones a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document to clone
         * @param {string} newTitle Title of the new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDocument(
            model: string,
            title: string,
            newTitle: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError(
                    'model',
                    'Required parameter model was null or undefined when calling cloneDocument.'
                )
            }
            // verify required parameter 'title' is not null or undefined
            if (title === null || title === undefined) {
                throw new RequiredError(
                    'title',
                    'Required parameter title was null or undefined when calling cloneDocument.'
                )
            }
            // verify required parameter 'newTitle' is not null or undefined
            if (newTitle === null || newTitle === undefined) {
                throw new RequiredError(
                    'newTitle',
                    'Required parameter newTitle was null or undefined when calling cloneDocument.'
                )
            }
            const localVarPath = `/cloneDocument`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            if (model !== undefined) {
                localVarQueryParameter['model'] = model
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title
            }

            if (newTitle !== undefined) {
                localVarQueryParameter['newTitle'] = newTitle
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )

            localVarRequestOptions.credentials = 'include'

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Gets a new csrf token
         * @summary Gets a new csrf token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsrfToken(options: any = {}): FetchArgs {
            const localVarPath = `/getCsrfToken`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication URS4 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue =
                    typeof configuration.accessToken === 'function'
                        ? configuration.accessToken('URS4', ['read', 'write'])
                        : configuration.accessToken
                localVarHeaderParameter['Authorization'] =
                    'Bearer ' + localVarAccessTokenValue
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Gets user info
         * @summary Gets user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options: any = {}): FetchArgs {
            const localVarPath = `/me`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication URS4 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue =
                    typeof configuration.accessToken === 'function'
                        ? configuration.accessToken('URS4', ['read', 'write'])
                        : configuration.accessToken
                localVarHeaderParameter['Authorization'] =
                    'Bearer ' + localVarAccessTokenValue
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )

            localVarRequestOptions.credentials = 'include'

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Gets a Model object
         * @summary Gets a Model
         * @param {string} name Name of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError(
                    'name',
                    'Required parameter name was null or undefined when calling getModel.'
                )
            }
            const localVarPath = `/getModel`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            // authentication URS4 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue =
                    typeof configuration.accessToken === 'function'
                        ? configuration.accessToken('URS4', ['read', 'write'])
                        : configuration.accessToken
                localVarHeaderParameter['Authorization'] =
                    'Bearer ' + localVarAccessTokenValue
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Logs in a user
         * @summary Login
         * @param {string} [code] URS authentication code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(code?: string, options: any = {}): FetchArgs {
            const localVarPath = `/login`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            if (code !== undefined) {
                localVarQueryParameter['code'] = code
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
        /**
         * Logs out the user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options: any = {}): FetchArgs {
            const localVarPath = `/logout`
            const localVarUrlObj = url.parse(localVarPath, true)
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
            const localVarHeaderParameter = {} as any
            const localVarQueryParameter = {} as any

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            )
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            )

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            }
        },
    }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Clones a document
         * @summary Clones a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document to clone
         * @param {string} newTitle Title of the new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDocument(
            model: string,
            title: string,
            newTitle: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(
                configuration
            ).cloneDocument(model, title, newTitle, options)
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return configuration
                    .fetch(
                        basePath + localVarFetchArgs.url,
                        localVarFetchArgs.options
                    )
                    .then(response => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json()
                        } else {
                            throw response
                        }
                    })
            }
        },
        /**
         * Gets a new csrf token
         * @summary Gets a new csrf token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsrfToken(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Csrf> {
            const localVarFetchArgs =
                DefaultApiFetchParamCreator(configuration).getCsrfToken(options)
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return configuration
                    .fetch(
                        basePath + localVarFetchArgs.url,
                        localVarFetchArgs.options
                    )
                    .then(response => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json()
                        } else {
                            throw response
                        }
                    })
            }
        },
        /**
         * Gets user info
         * @summary Gets user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs =
                DefaultApiFetchParamCreator(configuration).getMe(options)
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return configuration
                    .fetch(
                        basePath + localVarFetchArgs.url,
                        localVarFetchArgs.options
                    )
                    .then(response => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json()
                        } else {
                            throw response
                        }
                    })
            }
        },
        /**
         * Gets a Model object
         * @summary Gets a Model
         * @param {string} name Name of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(
            name: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Model> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(
                configuration
            ).getModel(name, options)
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return configuration
                    .fetch(
                        basePath + localVarFetchArgs.url,
                        localVarFetchArgs.options
                    )
                    .then(response => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json()
                        } else {
                            throw response
                        }
                    })
            }
        },
        /**
         * Logs in a user
         * @summary Login
         * @param {string} [code] URS authentication code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(
            code?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(
                configuration
            ).login(code, options)
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return configuration
                    .fetch(
                        basePath + localVarFetchArgs.url,
                        localVarFetchArgs.options
                    )
                    .then(response => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json()
                        } else {
                            throw response
                        }
                    })
            }
        },
        /**
         * Logs out the user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Success> {
            const localVarFetchArgs =
                DefaultApiFetchParamCreator(configuration).logout(options)
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return configuration
                    .fetch(
                        basePath + localVarFetchArgs.url,
                        localVarFetchArgs.options
                    )
                    .then(response => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json()
                        } else {
                            throw response
                        }
                    })
            }
        },
    }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Clones a document
         * @summary Clones a document
         * @param {string} model Name of the Model
         * @param {string} title Title of the document to clone
         * @param {string} newTitle Title of the new document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDocument(model: string, title: string, newTitle: string, options?: any) {
            return DefaultApiFp(configuration).cloneDocument(
                model,
                title,
                newTitle,
                options
            )(fetch, basePath)
        },
        /**
         * Gets a new csrf token
         * @summary Gets a new csrf token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCsrfToken(options?: any) {
            return DefaultApiFp(configuration).getCsrfToken(options)(fetch, basePath)
        },
        /**
         * Gets user info
         * @summary Gets user info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any) {
            return DefaultApiFp(configuration).getMe(options)(fetch, basePath)
        },
        /**
         * Gets a Model object
         * @summary Gets a Model
         * @param {string} name Name of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(name: string, options?: any) {
            return DefaultApiFp(configuration).getModel(name, options)(
                fetch,
                basePath
            )
        },
        /**
         * Logs in a user
         * @summary Login
         * @param {string} [code] URS authentication code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(code?: string, options?: any) {
            return DefaultApiFp(configuration).login(code, options)(fetch, basePath)
        },
        /**
         * Logs out the user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any) {
            return DefaultApiFp(configuration).logout(options)(fetch, basePath)
        },
    }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Clones a document
     * @summary Clones a document
     * @param {string} model Name of the Model
     * @param {string} title Title of the document to clone
     * @param {string} newTitle Title of the new document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cloneDocument(
        model: string,
        title: string,
        newTitle: string,
        options?: any
    ) {
        return DefaultApiFp(this.configuration).cloneDocument(
            model,
            title,
            newTitle,
            options
        )(this.fetch, this.basePath)
    }

    /**
     * Gets a new csrf token
     * @summary Gets a new csrf token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCsrfToken(options?: any) {
        return DefaultApiFp(this.configuration).getCsrfToken(options)(
            this.fetch,
            this.basePath
        )
    }

    /**
     * Gets user info
     * @summary Gets user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMe(options?: any) {
        return DefaultApiFp(this.configuration).getMe(options)(
            this.fetch,
            this.basePath
        )
    }

    /**
     * Gets a Model object
     * @summary Gets a Model
     * @param {string} name Name of the model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getModel(name: string, options?: any) {
        return DefaultApiFp(this.configuration).getModel(name, options)(
            this.fetch,
            this.basePath
        )
    }

    /**
     * Logs in a user
     * @summary Login
     * @param {string} [code] URS authentication code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(code?: string, options?: any) {
        return DefaultApiFp(this.configuration).login(code, options)(
            this.fetch,
            this.basePath
        )
    }

    /**
     * Logs out the user
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logout(options?: any) {
        return DefaultApiFp(this.configuration).logout(options)(
            this.fetch,
            this.basePath
        )
    }
}
